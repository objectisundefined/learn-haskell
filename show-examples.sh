#!/bin/bash

echo "🔥 HASKELL POWER EXAMPLES - Overview"
echo "===================================="
echo ""

echo "📊 Repository Statistics:"
echo "- Total Haskell files: $(ls -1 *.hs | wc -l)"
echo "- Total lines of code: $(wc -l *.hs | tail -1 | awk '{print $1}')"
echo "- New advanced examples added: 6"
echo ""

echo "🚀 NEW ADVANCED EXAMPLES (showing Haskell's unique power):"
echo ""

echo "1. 🔄 LAZY EVALUATION & INFINITE DATA STRUCTURES"
echo "   File: lazy-infinite-structures.hs ($(wc -l < lazy-infinite-structures.hs) lines)"
echo "   • Infinite Fibonacci sequence using zipWith"
echo "   • Prime sieve with infinite lists"
echo "   • Hamming numbers (elegant corecursion)"
echo "   • Pascal's triangle generation"
echo ""

echo "2. 🔬 TYPE-LEVEL PROGRAMMING"
echo "   File: type-level-programming.hs ($(wc -l < type-level-programming.hs) lines)"
echo "   • Compile-time arithmetic with type families"
echo "   • Length-indexed vectors (impossible array bounds errors)"
echo "   • Type-safe units of measurement"
echo "   • GADTs for expressing complex invariants"
echo ""

echo "3. 🏗️  FREE MONADS & DSL CREATION"
echo "   File: free-monads-dsl.hs ($(wc -l < free-monads-dsl.hs) lines)"
echo "   • Separate program structure from interpretation"
echo "   • Multiple interpreters (pure testing vs IO production)"
echo "   • Console, file system, and database DSLs"
echo "   • Composable effect systems"
echo ""

echo "4. 🧮 CATEGORY THEORY IN PRACTICE"
echo "   File: category-theory-practice.hs ($(wc -l < category-theory-practice.hs) lines)"
echo "   • Functors, Applicatives, Monads explained"
echo "   • Kleisli composition for safe operations"
echo "   • Yoneda lemma for performance optimization"
echo "   • Comonads and mathematical abstractions"
echo ""

echo "5. ⚡ ADVANCED CONCURRENCY"
echo "   File: advanced-concurrency.hs ($(wc -l < advanced-concurrency.hs) lines)"
echo "   • Software Transactional Memory (STM) - no locks needed!"
echo "   • Composable atomic transactions"
echo "   • Parallel algorithms with async"
echo "   • Lock-free data structures"
echo ""

echo "6. 🎭 METAPROGRAMMING & GENERICS"
echo "   File: metaprogramming-generics.hs ($(wc -l < metaprogramming-generics.hs) lines)"
echo "   • Template Haskell for compile-time code generation"
echo "   • Generic programming - write once, works for all types"
echo "   • Automatic lens generation"
echo "   • Type-safe reflection with Data.Data"
echo ""

echo "🎯 EXISTING POWERHOUSE EXAMPLES:"
echo "• JSON Parser: Full parser combinator implementation ($(wc -l < json-parser.hs) lines)"
echo "• Red-Black Trees: Self-balancing functional trees ($(wc -l < red-black-tree.hs) lines)"
echo "• Advanced Lenses: Van Laarhoven lens library ($(wc -l < advanced-lens.hs) lines)"
echo "• Fundamental Monads: Reader, Writer, State ($(wc -l < five-fundamental-monads.hs) lines)"
echo "• Template Haskell: Compile-time metaprogramming ($(wc -l < template-programming.hs) lines)"
echo ""

echo "💪 WHY THESE EXAMPLES SHOWCASE HASKELL'S UNIQUE STRENGTHS:"
echo ""
echo "🔒 Type Safety: Many runtime errors become compile-time errors"
echo "♾️  Lazy Evaluation: Work with infinite data structures efficiently"
echo "🧵 Safe Concurrency: STM makes concurrent programming composable"
echo "🏗️  DSL Power: Build domain-specific languages with ease"
echo "🎯 Mathematical Precision: Direct implementation of category theory"
echo "⚡ Zero-cost Abstractions: High-level code compiles to fast machine code"
echo "🔄 Immutability: No accidental mutations, referential transparency"
echo "🎪 Metaprogramming: Generate code at compile time safely"
echo ""

echo "🚀 Try these examples to see Haskell's power in action!"
echo ""
echo "Get started:"
echo "  ghci lazy-infinite-structures.hs    # Explore infinite data"
echo "  ghci category-theory-practice.hs    # See math in action"
echo "  ghci free-monads-dsl.hs            # Build your own DSL"
echo ""
echo "Haskell: Where mathematics meets practical programming! 🎉"